;; And God said, Let there be light:

($begin
  ($define! $quote ($vau (x) _ x))

  ($define! env ($vau () env env))

  ($define! root (env))

  ($define! list
    (wrap ($vau lst _ lst)))

  ; you will like this alias when writing macros
  ($define! @ list)

  ($define! $lambda
    ($vau (params expr) env
          (env (@ wrap
                     (@ $vau params '_ expr)))))

  ; since $vau immediately binds/drops the 'rest' parameter
  ; car is an O(1) operation
  ($define! car
    (($lambda ($car)
              ($lambda (lst)
                       (root (cons $car lst))))
     ; to avoid constructing an operative each time
     ($vau (x . _) _ x)))

  ($define! cdr
    (($lambda ($cdr)
              ($lambda (lst)
                       (root (cons $cdr lst))))
     ($vau (_ . x) _ x)))

  ($define! null? ($lambda (lst) (eq? lst ())))

  ($define! map
    ($lambda (func lst)
             ($if (null? lst)
                  ()
                  (cons
                    (func (car lst))
                    (map func (cdr lst))))))

  ($define! unwrap
    ($lambda (app)
             ($vau args env
                   (env (cons app
                              (map ($lambda (x) (@ $quote x))
                                   args))))))

  ($define! cadr ($lambda (lst) (car (cdr lst))))

  ($define! $let
    ($vau (bindings body) env
          (env
            (cons
              (@ $lambda (map car bindings) body)
              (map cadr bindings)))))

  ($define! true (eq? 0 0))
  ($define! false (eq? 0 1))

  ($define! child ($lambda (parent)
                           (parent (@ $let () (@ env)))))

  ($define! $import ($vau (sym) _
                          ($let ((module (child root)))
                            (module (@ $raw-import! sym)))))

  ($define! $export
    ($vau exports private
          ($let ((public (child root)))
            ($begin
              (map ($lambda (sym)
                            (public
                              (@ $define! sym (private sym))))
                   exports)
              (unwrap public)))))

  ($define! $and
    ($vau (a b) env
          ($if (env a)
               ($if (env b)
                    true
                    false)
               false)))

  ($define! $or
    ($vau (a b) env
          ($if (env a)
               true
               ($if (env b)
                    true
                    false))))

  ($define! not
    ($lambda (x)
             ($if x
                  false
                  true)))

  ($define! <= ($lambda (a b) ($or (eq? a b) (< a b))))

  ($define! - ($lambda (a b) (+ a (neg b))))

  ; since exported module references to the root module
  ; and we are in the root module
  ; we don't need to specify those symbols
  ($export))
